import logging
import asyncio
from typing import List, Dict
from fastapi import FastAPI, Depends, HTTPException, status, WebSocket, WebSocketDisconnect
from fastapi.security import OAuth2PasswordRequestForm
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from datetime import timedelta

import crud, models, schemas, security, initial_data
from database import engine, SessionLocal, get_db
from schemas import User, Token
from security import create_access_token, ACCESS_TOKEN_EXPIRE_MINUTES

# --- Database Initialization ---
models.Base.metadata.create_all(bind=engine)

# --- FastAPI App Initialization ---
app = FastAPI(
    title="ChainTrace Central Server",
    description="Backend server for the ChainTrace application, managing data, authentication, and real-time collaboration.",
    version="1.0.0",
)

# --- CORS Middleware ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, restrict this to your frontend's domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Initial Data Seeding ---
@app.on_event("startup")
def on_startup():
    db = SessionLocal()
    try:
        initial_data.init_db(db)
    finally:
        db.close()
    
# --- WebSocket Connection Manager ---
class ConnectionManager:
    def __init__(self):
        # Maps device_id to a dictionary of {username: websocket}
        self.active_connections: Dict[str, Dict[str, WebSocket]] = {}

    async def connect(self, websocket: WebSocket, device_id: str, username: str):
        await websocket.accept()
        if device_id not in self.active_connections:
            self.active_connections[device_id] = {}
        self.active_connections[device_id][username] = websocket
        logging.info(f"User '{username}' connected to device '{device_id}' room.")
        await self.broadcast_users(device_id)

    def disconnect(self, device_id: str, username: str):
        if device_id in self.active_connections and username in self.active_connections[device_id]:
            del self.active_connections[device_id][username]
            if not self.active_connections[device_id]: # Clean up empty room
                del self.active_connections[device_id]
            logging.info(f"User '{username}' disconnected from device '{device_id}' room.")

    async def broadcast_users(self, device_id: str):
        if device_id in self.active_connections:
            user_list = list(self.active_connections[device_id].keys())
            message = {"type": "USER_LIST_UPDATE", "payload": user_list}
            await asyncio.gather(*[
                connection.send_json(message)
                for connection in self.active_connections[device_id].values()
            ])
            logging.info(f"Broadcasted user list for device '{device_id}': {user_list}")

    async def broadcast_new_block(self, device_id: str, block: models.Block):
        if device_id in self.active_connections:
            # FIX: Convert the SQLAlchemy ORM model to a Pydantic model before serializing.
            # This prevents a server crash when trying to call a Pydantic method on a non-Pydantic object.
            pydantic_block = schemas.Block.model_validate(block)
            message = {"type": "NEW_BLOCK", "payload": pydantic_block.model_dump(mode="json")}
            logging.info(f"Broadcasting new block for device '{device_id}'.")
            await asyncio.gather(*[
                connection.send_json(message)
                for connection in self.active_connections[device_id].values()
            ])

manager = ConnectionManager()

# --- API Endpoints ---

# --- Authentication ---
@app.post("/api/token", response_model=Token)
async def login_for_access_token(db: Session = Depends(get_db), form_data: OAuth2PasswordRequestForm = Depends()):
    user = security.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

# --- Users ---
@app.get("/api/users/me", response_model=schemas.User)
async def read_users_me(current_user: schemas.User = Depends(security.get_current_active_user)):
    return current_user

# --- Devices ---
@app.get("/api/devices", response_model=List[schemas.Device])
def read_devices(db: Session = Depends(get_db), current_user: User = Depends(security.get_current_active_user)):
    devices = crud.get_devices(db)
    return devices

@app.get("/api/devices/{device_id}", response_model=schemas.DeviceWithBlocks)
def read_device(device_id: str, db: Session = Depends(get_db), current_user: User = Depends(security.get_current_active_user)):
    db_device = crud.get_device(db, device_id=device_id)
    if db_device is None:
        raise HTTPException(status_code=404, detail="Device not found")
    return db_device

@app.post("/api/devices", response_model=schemas.Device, status_code=status.HTTP_201_CREATED)
def create_device(device: schemas.DeviceCreate, db: Session = Depends(get_db), current_user: User = Depends(security.get_current_admin_user)):
    db_device = crud.get_device(db, device_id=device.id)
    if db_device:
        raise HTTPException(status_code=400, detail="Device ID already registered")
    return crud.create_device(db=db, device=device)

@app.delete("/api/devices/{device_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_device(device_id: str, db: Session = Depends(get_db), current_user: User = Depends(security.get_current_admin_user)):
    db_device = crud.get_device(db, device_id=device_id)
    if not db_device:
        raise HTTPException(status_code=404, detail="Device not found")
    crud.delete_device(db=db, device_id=device_id)
    return

# --- Blockchain ---
@app.post("/api/devices/{device_id}/blockchain", response_model=schemas.Block, status_code=status.HTTP_201_CREATED)
async def add_block_to_device(device_id: str, block: schemas.BlockCreate, db: Session = Depends(get_db), current_user: User = Depends(security.get_current_active_user)):
    new_block = crud.add_block(db=db, block=block, device_id=device_id)
    await manager.broadcast_new_block(device_id, new_block)
    return new_block


# --- Admin ---
@app.post("/api/reset-data", status_code=status.HTTP_204_NO_CONTENT)
def reset_database(db: Session = Depends(get_db), current_user: User = Depends(security.get_current_admin_user)):
    initial_data.reset_db(db)
    return

# --- WebSocket Endpoint ---
@app.websocket("/ws/{device_id}/{username}")
async def websocket_endpoint(websocket: WebSocket, device_id: str, username: str):
    await manager.connect(websocket, device_id, username)
    try:
        while True:
            # Keep the connection alive by waiting for messages (even if none are expected from client)
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(device_id, username)
        await manager.broadcast_users(device_id)

if __name__ == "__main__":
    import uvicorn
    # This is for running the script directly for debugging
    uvicorn.run("main:app", host="127.0.0.1", port=8000, reload=True)