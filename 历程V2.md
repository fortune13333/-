# “链踪”项目演进历程 V2 - 架构新生

本文档将专门记录“链踪”项目从一个基于 `localStorage` 的单机应用，向一个拥有**中央后端服务器、数据库、并具备真正实时协作能力**的企业级平台的重大架构演进过程。

这是项目从 V4.2 版本之后开启的全新篇章，标志着“链踪”从一个精巧的工具，正式迈向一个可伸缩、多用户的协作平台。

---

### **阶段一: 构建“真理之源” - 中央后端与数据库**

这是“架构新生”的第一步，也是最关键的一步。我们的目标是构建一个强大、可靠的中央后端，它将取代前端的 `localStorage`，成为整个应用**唯一的数据“真理之源”**。

- **目标**: 彻底替换掉基于浏览器的本地存储，构建一个功能完整的、持久化的后端系统。
- **技术栈**: FastAPI, SQLAlchemy, SQLite, Pydantic, JWT.
- **核心实现**:
    1.  **数据库建模 (`models.py`)**: 使用 SQLAlchemy ORM 精心设计了 `User`, `Device`, `Block` 三个核心数据模型，并建立了它们之间的关系。这为数据的持久化和一致性打下了坚实的基础。
    2.  **数据访问层 (`crud.py`)**: 实现了所有数据库的增删改查 (CRUD) 操作。通过将数据访问逻辑与API路由处理分离，我们构建了一个清晰、可维护的代码结构。
    3.  **API与数据模式 (`main.py`, `schemas.py`)**: 使用 FastAPI 和 Pydantic 定义了一整套 RESTful API 接口，覆盖了用户认证、设备管理、区块链操作等所有核心功能。Pydantic 的模型确保了前后端数据交换的类型安全和格式校验。
    4.  **安全与认证 (`security.py`)**: 实现了基于 JWT 的用户认证机制，包括密码哈希和访问令牌的生成与验证，为应用提供了企业级的安全保障。
    5.  **自动化数据填充 (`initial_data.py`)**: 编写了启动脚本，可以在数据库首次创建时，自动填充与原前端应用完全一致的初始设备、创世区块和模拟用户信息，确保了新旧架构的平滑过渡。

- **当前状态**:
    我们已成功构建并运行了一个功能完备的中央后端服务器。它现在拥有自己的数据库，能够独立处理所有数据逻辑，并为前端提供了一套标准化的API。
    **“真理之源”已经建立。** 下一步，我们将改造前端应用，使其与这个全新的后端服务进行通信。
---

### **阶段二: 前端数据源迁移 - 连接“真理之源”**

在后端“真理之源”建立之后，此阶段的核心任务是**彻底改造前端应用**，将其从一个依赖浏览器 `localStorage` 的独立应用，转变为一个真正的、依赖后端API的“智能客户端”。

- **目标**: 将前端所有的数据读写操作，全部切换为通过网络请求与中央后端服务器进行通信，并引入完整的用户认证流程。
- **技术栈**: React Hooks (`useEffect`, `useState`), Fetch API, `react-hot-toast`.
- **核心实现**:
    1.  **服务层抽象 (`services/apiService.ts`)**: 创建了一个专用的API服务层。这个 `ApiService` 单例封装了所有与后端通信的逻辑，包括 `fetch` 调用、自动附加JWT认证头、以及统一的错误处理。这使得组件代码可以从具体的网络请求实现中解耦，变得更清晰。
    2.  **认证流程实现**:
        -   在应用根组件 (`App.tsx`) 中实现了完整的认证生命周期：应用加载时，尝试用 `sessionStorage` 中的Token获取用户信息；如果失败或无Token，则渲染 `Login` 组件；登录成功后，获取并全局存储当前用户信息，并以此作为触发数据加载的信号。
        -   登出操作现在会清除 `sessionStorage` 并重置所有应用状态，将用户导回登录页面。
    3.  **数据流重构**:
        -   **读取**: 在用户成功认证后，应用通过 `apiService.getDevices()` 获取设备列表。当用户选择一个设备时，通过 `apiService.getDeviceWithBlockchain(id)` 获取详细的配置历史。
        -   **写入**: 所有的数据变更操作（添加/删除设备、提交新配置、回滚）现在都通过调用 `apiService` 中对应的 `POST`, `DELETE` 方法来完成。
        -   **状态同步**: 在每次写入操作成功后，前端会用API返回的最新数据来智能地更新本地状态，确保了UI的实时响应，避免了不必要的重新加载。
    4.  **遗留代码清理**: 彻底删除了原有的、基于 `localStorage` 实现的模拟会话管理工具 (`utils/session.ts`)，因为它已被后端的WebSocket实时状态广播功能完全取代。

- **当前状态**:
    前端迁移已全面完成。“链踪”现在是一个标准的客户端-服务器 (C/S)架构应用。所有的数据持久化、业务逻辑和用户身份认证都由中央后端统一管理，前端则专注于数据的展示和用户交互。
    **“智能客户端”已与“真理之源”成功对接。**
---

### **阶段三: 激活实时协作 - 对接 WebSocket**

在前两个阶段奠定了坚实的C/S架构基础后，此阶段的目标是注入“灵魂”，将“链踪”从一个静态的客户端-服务器应用，升级为一个动态的、事件驱动的**实时协作平台**。

- **目标**: 利用后端已有的 WebSocket 能力，彻底解决多用户间数据视图不同步的问题，实现真正的实时协同工作。
- **核心实现**:
    1.  **建立持久连接**: 在前端 `DeviceDetails.tsx` 组件中，使用 `useEffect` Hook 来管理 WebSocket 的完整生命周期。当用户进入该页面查看特定设备时，组件会立即向后端发起一个 WebSocket 连接请求 (`ws://...`)，并加入该设备的“实时房间”。
    2.  **实时事件处理**:
        -   **用户状态同步**: 前端现在会监听由服务器主动推送的 `USER_LIST_UPDATE` 事件。一旦房间内成员发生变化（有新用户进入或离开），所有客户端都会收到最新的用户列表，并通过 `CollaborationStatus` 组件实时更新“在线用户”提示，实现“谁也在这里”的精准感知。
        -   **数据实时同步**: 这是本阶段的核心。当任何一个用户成功提交新配置后，后端会广播一个 `NEW_BLOCK` 事件，其中包含了新创建区块的完整数据。其他所有客户端在收到此事件后，会触发 `handleRealtimeBlockAdd` 函数，**自动、无刷新地**将新区块追加到本地的配置历史列表中，并弹出一个友好的通知。
    3.  **智能消息过滤**: 为了避免操作者本人收到自己操作的重复通知，前端在处理 `NEW_BLOCK` 事件时，会检查新区块的 `operator` 字段是否为当前用户。只有当操作者是其他人时，才会触发UI更新和通知，提升了用户体验的流畅性。
    4.  **连接健壮性**: `useEffect` 的清理函数确保了当用户离开设备详情页或切换到其他设备时，旧的 WebSocket 连接会被干净地关闭，避免了资源泄漏和不必要的数据接收。

- **当前状态**:
    实时协作功能已全面激活。“链踪”现在不仅能确保数据的集中和持久化，更能保证所有在线用户的数据视图**始终保持最终一致性**。它从一个高效的单人工具，成功演进为一个支持多用户实时协同工作的企业级平台。
    **“架构新生”计划的所有核心目标均已达成。**
---

### **最终阶段: 代码审查与健壮性加固**

在完成了所有核心功能的架构演进后，我们进行了最后一次全面的代码审查，旨在将代码质量提升至生产级标准。此阶段不涉及新功能，但对于项目的长期健康至关重要。

- **目标**: 识别并修复潜在的代码问题，提升可维护性、健壮性与稳定性。
- **核心改进**:
    1.  **配置集中化**: 创建了 `constants.ts` 文件，将后端 API 和 WebSocket 的基础 URL 统一管理。所有依赖这些地址的组件（如 `apiService.ts`, `DeviceDetails.tsx`）现在都从这个单一来源导入，彻底消除了硬编码，使得未来在不同环境中部署或迁移变得极其简单。
    2.  **Bug 修复**: 修复了 `App.tsx` 中 `handleUpdateSettings` 函数的一个逻辑缺陷。原有的合并逻辑可能导致在更新部分设置（如本地代理地址）时，意外地重置其他嵌套的AI配置。通过实现一个正确的深度合并（deep merge），确保了用户配置的完整性和持久性。
    3.  **代码清理**: 移除了代码库中一些未被使用的遗留函数和变量，保持了项目的整洁。

- **当前状态**:
    项目代码库经过了全面的审查和加固，不仅功能强大、架构清晰，而且在细节上同样可靠、易于维护。至此，“链踪”项目已达到一个高度成熟和完整的状态。