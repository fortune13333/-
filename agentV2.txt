#
# ChainTrace Agent V3.0 - LAN Collaboration Server
#
import sys
import configparser
import logging
import json
import threading
import datetime
import hashlib
from pathlib import Path
from typing import Dict, List, Any

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from netmiko import ConnectHandler, NetmikoAuthenticationException, NetmikoTimeoutException

# --- Basic Setup ---

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Data File and Lock ---
DATA_FILE = Path("chaintrace_data.json")
# Thread lock to prevent race conditions when reading/writing the JSON data file
data_lock = threading.Lock()

# --- Initial Data Structure ---
# This will be used if chaintrace_data.json does not exist.
INITIAL_DATA = {
    "devices": [
        {"id": "RTR01-NYC", "name": "Core Router NYC", "ipAddress": "192.168.1.1", "type": "Router"},
        {"id": "SW01-SFO", "name": "Access Switch SFO", "ipAddress": "10.10.5.254", "type": "Switch"},
        {"id": "FW01-LON", "name": "Edge Firewall London", "ipAddress": "203.0.113.1", "type": "Firewall"},
    ],
    "blockchains": {
        "RTR01-NYC": [{
            "index": 0, "timestamp": "2023-01-01T10:00:00Z",
            "data": {
                "deviceId": "RTR01-NYC", "version": 1, "operator": "system_init",
                "config": "hostname RTR01-NYC\n!\ninterface GigabitEthernet0/0\n ip address 192.168.1.1 255.255.255.0\n no shutdown\n!\nrouter ospf 1\n network 192.168.1.0 0.0.0.255 area 0\n!\nend",
                "diff": "+ hostname RTR01-NYC\n+ !\n+ interface GigabitEthernet0/0\n+  ip address 192.168.1.1 255.255.255.0\n+  no shutdown\n+ !\n+ router ospf 1\n+  network 192.168.1.0 0.0.0.255 area 0\n+ !\n+ end",
                "changeType": "initial", "summary": "初始系统配置。",
                "analysis": "这是设备的第一个配置区块，用于建立基线。",
                "security_risks": "无。这是一个标准的初始设置。",
            },
            "prev_hash": "0", "hash": "4a58241e383de98ce0cc38a84a63a5d0fbb8daf9cb8607f96bca9bdbfbc1b04a"
        }],
        "SW01-SFO": [{
            "index": 0, "timestamp": "2023-01-02T11:30:00Z",
            "data": {
                "deviceId": "SW01-SFO", "version": 1, "operator": "system_init",
                "config": "hostname SW01-SFO\n!\nvlan 10\n name USERS\n!\ninterface FastEthernet0/1\n switchport mode access\n switchport access vlan 10\n!\nend",
                "diff": "+ hostname SW01-SFO\n+ !\n+ vlan 10\n+  name USERS\n+ !\n+ interface FastEthernet0/1\n+  switchport mode access\n+  switchport access vlan 10\n+ !\n+ end",
                "changeType": "initial", "summary": "初始系统配置。",
                "analysis": "这是设备的第一个配置区块，用于建立基线。",
                "security_risks": "无。这是一个标准的初始设置。",
            },
            "prev_hash": "0", "hash": "8525b6999335f60b45d06456f43702951b1a43a75871f3014a6e35591e1d318e"
        }],
        "FW01-LON": [{
            "index": 0, "timestamp": "2023-01-03T09:00:00Z",
            "data": {
                "deviceId": "FW01-LON", "version": 1, "operator": "system_init",
                "config": "hostname FW01-LON\n!\nip access-list extended INCOMING_FILTER\n permit tcp any host 203.0.113.1 eq 443\n deny ip any any log\n!\ninterface GigabitEthernet0/1\n ip access-group INCOMING_FILTER in\n!\nend",
                "diff": "+ hostname FW01-LON\n+ !\n+ ip access-list extended INCOMING_FILTER\n+  permit tcp any host 203.0.113.1 eq 443\n+  deny ip any any log\n+ !\n+ interface GigabitEthernet0/1\n+  ip access-group INCOMING_FILTER in\n+ !\n+ end",
                "changeType": "initial", "summary": "初始系统配置。",
                "analysis": "这是设备的第一个配置区块，用于建立基线。",
                "security_risks": "无。这是一个标准的初始设置。",
            },
            "prev_hash": "0", "hash": "3650a3163351368a27d142b918738327b87c712852277d3257085a3c631e7845"
        }]
    }
}

# --- Data Handling Functions ---

def load_data() -> Dict[str, Any]:
    """Loads data from the JSON file. Creates it if it doesn't exist."""
    with data_lock:
        if not DATA_FILE.exists():
            logging.info(f"{DATA_FILE} not found. Creating with initial data.")
            save_data(INITIAL_DATA)
            return INITIAL_DATA
        try:
            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            logging.error(f"Error reading {DATA_FILE}: {e}. Returning empty structure.")
            return {"devices": [], "blockchains": {}}

def save_data(data: Dict[str, Any]):
    """Saves data to the JSON file."""
    with data_lock:
        try:
            with open(DATA_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except IOError as e:
            logging.error(f"Could not write to {DATA_FILE}: {e}")

# --- Configuration Loading ---

config = configparser.ConfigParser()
try:
    config.read('config.ini', encoding='utf-8')
    if not config.sections():
        raise FileNotFoundError("config.ini not found or is empty.")
except (configparser.Error, FileNotFoundError, UnicodeDecodeError) as e:
    logging.error(f"CRITICAL: An unexpected error occurred while reading config.ini: {e}")
    sys.exit(1)

# --- API Models ---

class Device(BaseModel):
    id: str
    name: str
    ipAddress: str
    type: str

class BlockData(BaseModel):
    deviceId: str
    version: int
    operator: str
    config: str
    diff: str
    changeType: str
    summary: str
    analysis: str
    security_risks: str

class Block(BaseModel):
    index: int
    timestamp: str
    data: BlockData
    prev_hash: str
    hash: str
    
class ConfigPayload(BaseModel):
    config: str

# --- FastAPI App Initialization ---

app = FastAPI(
    title="ChainTrace Local Agent",
    description="Acts as a bridge between the ChainTrace UI and real network devices, and serves as the central data store for LAN collaboration.",
    version="3.0.0",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Helper Functions ---

def get_device_info(device_id: str):
    device_id_upper = device_id.upper()
    if not config.has_option('device_map', device_id_upper):
        logging.warning(f"Device ID '{device_id}' not found in config.ini's [device_map].")
        return None
    try:
        host, device_type = config.get('device_map', device_id_upper).split(',')
        return {
            'host': host.strip(),
            'device_type': device_type.strip(),
            'username': config.get('credentials', 'username'),
            'password': config.get('credentials', 'password'),
            'secret': config.get('credentials', 'secret', fallback=None),
            'timeout': 15,  # Add a 15-second connection timeout for better UX
        }
    except (configparser.NoSectionError, configparser.NoOptionError) as e:
        logging.error(f"Configuration error for device '{device_id}': {e}")
        return None

def is_simulation_mode():
    try:
        return config.get('credentials', 'username').upper() == 'SIM_USER'
    except (configparser.NoSectionError, configparser.NoOptionError):
        return False

# --- API Endpoints ---

# --- Data Management API ---
@app.get("/api/data")
def get_all_data():
    logging.info("Request received for GET /api/data")
    return load_data()

@app.post("/api/reset", status_code=204)
def reset_data():
    logging.warning("Request received to RESET all data.")
    save_data(INITIAL_DATA)
    return {}

@app.post("/api/devices", response_model=Device, status_code=201)
def add_device(device: Device):
    logging.info(f"Request received to ADD device: {device.id}")
    data = load_data()
    
    if any(d['id'] == device.id for d in data['devices']):
        raise HTTPException(status_code=409, detail=f"Device with ID '{device.id}' already exists.")
    
    data['devices'].append(device.dict())
    
    # Create a genesis block for the new device
    genesis_block_data = {
        "deviceId": device.id, "version": 1, "operator": "system_init",
        "config": f"hostname {device.name}\n!\n! Initial configuration created by ChainTrace.",
        "diff": f"+ hostname {device.name}\n+ !\n+ ! Initial configuration created by ChainTrace.",
        "changeType": "initial", "summary": "设备已创建。",
        "analysis": "这是新设备的第一个配置区块，用于建立基线。",
        "security_risks": "无。这是一个标准的初始设置。",
    }
    timestamp = datetime.datetime.utcnow().isoformat() + "Z"
    prev_hash = "0"
    index = 0
    
    block_content_str = f"{index}{timestamp}{json.dumps(genesis_block_data, sort_keys=True, separators=(',', ':'))}{prev_hash}"
    hash_hex = hashlib.sha256(block_content_str.encode('utf-8')).hexdigest()
    
    genesis_block = {
        "index": index, "timestamp": timestamp, "data": genesis_block_data,
        "prev_hash": prev_hash, "hash": hash_hex
    }
    data['blockchains'][device.id] = [genesis_block]
    
    save_data(data)
    return device

@app.delete("/api/devices/{device_id}", status_code=204)
def delete_device(device_id: str):
    logging.info(f"Request received to DELETE device: {device_id}")
    data = load_data()
    
    initial_device_count = len(data['devices'])
    data['devices'] = [d for d in data['devices'] if d['id'] != device_id]
    
    if len(data['devices']) == initial_device_count:
        raise HTTPException(status_code=404, detail=f"Device with ID '{device_id}' not found.")
        
    if device_id in data['blockchains']:
        del data['blockchains'][device_id]
    
    save_data(data)
    return {}

@app.post("/api/blockchains/{device_id}", response_model=Block, status_code=201)
def add_block(device_id: str, block: Block):
    logging.info(f"Request received to ADD block to device: {device_id}")
    data = load_data()
    
    if device_id not in data['blockchains']:
        raise HTTPException(status_code=404, detail=f"Blockchain for device ID '{device_id}' not found.")
    
    data['blockchains'][device_id].append(block.dict())
    save_data(data)
    return block

# --- Device Interaction API ---
@app.get("/api/health")
def health_check():
    logging.info("Health check endpoint was hit.")
    return {"status": "ok", "message": "ChainTrace Agent is running."}

@app.get("/api/device/{device_id}/config")
def get_config(device_id: str):
    logging.info(f"Received request to GET config for device: {device_id}")
    if is_simulation_mode():
        logging.info(f"SIMULATION MODE: Returning mock configuration for {device_id}.")
        mock_config = f"hostname {device_id}\n!\ninterface Loopback0\n ip address 1.1.1.1 255.255.255.255\n!\n! End of simulated config"
        return {"config": mock_config}

    device_info = get_device_info(device_id)
    if not device_info:
        raise HTTPException(status_code=404, detail=f"Device ID '{device_id}' not found in configuration.")

    try:
        logging.info(f"Attempting to connect to {device_info['host']}...")
        with ConnectHandler(**device_info) as net_connect:
            net_connect.enable()
            output = net_connect.send_command('show running-config', expect_string=r'#')
        logging.info(f"Successfully retrieved config from {device_info['host']}.")
        return {"config": output}
    except NetmikoTimeoutException:
        logging.error(f"Connection to {device_info['host']} timed out.")
        raise HTTPException(status_code=504, detail="Connection timed out. Check IP address and network connectivity.")
    except NetmikoAuthenticationException:
        logging.error(f"Authentication failed for {device_info['host']}.")
        raise HTTPException(status_code=401, detail="Authentication failed. Check credentials in config.ini.")
    except Exception as e:
        logging.error(f"An unexpected error occurred for device {device_id}: {e}")
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

@app.post("/api/device/{device_id}/config")
def set_config(device_id: str, payload: ConfigPayload):
    logging.info(f"Received request to POST config for device: {device_id}")
    if is_simulation_mode():
        logging.info(f"SIMULATION MODE: Simulating configuration push for {device_id}.")
        return {"status": "success", "message": "Configuration push simulated successfully."}

    device_info = get_device_info(device_id)
    if not device_info:
        raise HTTPException(status_code=404, detail=f"Device ID '{device_id}' not found in configuration.")
    
    config_commands = payload.config.splitlines()
    if not config_commands:
        raise HTTPException(status_code=400, detail="Configuration payload cannot be empty.")

    try:
        logging.info(f"Attempting to connect to {device_info['host']} to push config...")
        with ConnectHandler(**device_info) as net_connect:
            net_connect.enable()
            output = net_connect.send_config_set(config_commands)
        logging.info(f"Successfully pushed config to {device_info['host']}. Output:\n{output}")
        return {"status": "success", "message": "Configuration pushed successfully.", "output": output}
    except NetmikoTimeoutException:
        logging.error(f"Connection to {device_info['host']} timed out.")
        raise HTTPException(status_code=504, detail="Connection timed out. Check IP address and network connectivity.")
    except NetmikoAuthenticationException:
        logging.error(f"Authentication failed for {device_info['host']}.")
        raise HTTPException(status_code=401, detail="Authentication failed. Check credentials in config.ini.")
    except Exception as e:
        logging.error(f"An unexpected error occurred while pushing config to {device_id}: {e}")
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

# --- Main Execution ---

if __name__ == "__main__":
    import uvicorn
    # Initialize data file on startup
    load_data()
    try:
        host = config.get('server', 'host', fallback='127.0.0.1')
        port = config.getint('server', 'port', fallback=8000)
        logging.info(f"Starting ChainTrace Agent server at http://{host}:{port}")
        uvicorn.run(app, host=host, port=port)
    except (configparser.NoSectionError, configparser.NoOptionError) as e:
        logging.error(f"Could not read server config from config.ini, using defaults. Error: {e}")
        uvicorn.run(app, host="127.0.0.1", port=8000)
