#
# ChainTrace Agent V3.5 - Collaboration Stability Final Fix
#
import sys
import configparser
import logging
import json
import threading
import datetime
import hashlib
from pathlib import Path
from typing import Dict, List, Any

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from netmiko import ConnectHandler, NetmikoAuthenticationException, NetmikoTimeoutException

# --- Basic Setup ---

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Data File and Lock ---
DATA_FILE = Path("chaintrace_data.json")
# Thread lock to prevent race conditions during read-modify-write operations
data_lock = threading.Lock()

# --- In-memory store for active user sessions ---
ACTIVE_SESSIONS: Dict[str, List[Dict[str, str]]] = {}
sessions_lock = threading.Lock()

# --- Hashing Helper ---
def _calculate_block_hash(block_data_dict: Dict, index: int, timestamp: str, prev_hash: str) -> str:
    """Calculates a deterministic SHA-256 hash for a block's content."""
    block_content_str = (
        f"{index}{timestamp}"
        f"{json.dumps(block_data_dict, sort_keys=True, separators=(',', ':'), ensure_ascii=False)}"
        f"{prev_hash}"
    )
    return hashlib.sha256(block_content_str.encode('utf-8')).hexdigest()

# --- Initial Data Structure ---
INITIAL_DATA_RAW = {
    "devices": [
        {"id": "RTR01-NYC", "name": "Core Router NYC", "ipAddress": "192.168.1.1", "type": "Router"},
        {"id": "SW01-SFO", "name": "Access Switch SFO", "ipAddress": "10.10.5.254", "type": "Switch"},
        {"id": "FW01-LON", "name": "Edge Firewall London", "ipAddress": "203.0.113.1", "type": "Firewall"},
    ],
    "blockchains": {
        "RTR01-NYC": [{
            "index": 0, "timestamp": "2023-01-01T10:00:00Z",
            "data": { "deviceId": "RTR01-NYC", "version": 1, "operator": "system_init", "config": "hostname RTR01-NYC\n!\ninterface GigabitEthernet0/0\n ip address 192.168.1.1 255.255.255.0\n no shutdown\n!\nrouter ospf 1\n network 192.168.1.0 0.0.0.255 area 0\n!\nend", "diff": "+ hostname RTR01-NYC\n+ !\n+ interface GigabitEthernet0/0\n+  ip address 192.168.1.1 255.255.255.0\n+  no shutdown\n+ !\n+ router ospf 1\n+  network 192.168.1.0 0.0.0.255 area 0\n+ !\n+ end", "changeType": "initial", "summary": "初始系统配置。", "analysis": "这是设备的第一个配置区块，用于建立基线。", "security_risks": "无。这是一个标准的初始设置。", }, "prev_hash": "0"
        }],
        "SW01-SFO": [{
            "index": 0, "timestamp": "2023-01-02T11:30:00Z",
            "data": { "deviceId": "SW01-SFO", "version": 1, "operator": "system_init", "config": "hostname SW01-SFO\n!\nvlan 10\n name USERS\n!\ninterface FastEthernet0/1\n switchport mode access\n switchport access vlan 10\n!\nend", "diff": "+ hostname SW01-SFO\n+ !\n+ vlan 10\n+  name USERS\n+ !\n+ interface FastEthernet0/1\n+  switchport mode access\n+  switchport access vlan 10\n+ !\n+ end", "changeType": "initial", "summary": "初始系统配置。", "analysis": "这是设备的第一个配置区块，用于建立基线。", "security_risks": "无。这是一个标准的初始设置。", }, "prev_hash": "0"
        }],
        "FW01-LON": [{
            "index": 0, "timestamp": "2023-01-03T09:00:00Z",
            "data": { "deviceId": "FW01-LON", "version": 1, "operator": "system_init", "config": "hostname FW01-LON\n!\nip access-list extended INCOMING_FILTER\n permit tcp any host 203.0.113.1 eq 443\n deny ip any any log\n!\ninterface GigabitEthernet0/1\n ip access-group INCOMING_FILTER in\n!\nend", "diff": "+ hostname FW01-LON\n+ !\n+ ip access-list extended INCOMING_FILTER\n+  permit tcp any host 203.0.113.1 eq 443\n+  deny ip any any log\n+ !\n+ interface GigabitEthernet0/1\n+  ip access-group INCOMING_FILTER in\n+ !\n+ end", "changeType": "initial", "summary": "初始系统配置。", "analysis": "这是设备的第一个配置区块，用于建立基线。", "security_risks": "无。这是一个标准的初始设置。", }, "prev_hash": "0"
        }]
    }
}

def get_initial_data_with_hashes():
    data = json.loads(json.dumps(INITIAL_DATA_RAW))
    for chain in data["blockchains"].values():
        for block in chain:
            block["hash"] = _calculate_block_hash(block["data"], block["index"], block["timestamp"], block["prev_hash"])
    return data

INITIAL_DATA = get_initial_data_with_hashes()

# --- Data Handling Functions ---

def _load_data_nolock() -> Dict[str, Any]:
    """Loads data without acquiring a lock. MUST be called from within a locked context."""
    if not DATA_FILE.exists():
        logging.info(f"{DATA_FILE} not found. Creating with initial data.")
        _save_data_nolock(INITIAL_DATA)
        return INITIAL_DATA
    try:
        with open(DATA_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError) as e:
        logging.error(f"Error reading {DATA_FILE}: {e}. Returning empty structure.")
        return {"devices": [], "blockchains": {}}

def _save_data_nolock(data: Dict[str, Any]):
    """Saves data without acquiring a lock. MUST be called from within a locked context."""
    try:
        with open(DATA_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    except IOError as e:
        logging.error(f"Could not write to {DATA_FILE}: {e}")

# --- Configuration Loading ---

config = configparser.ConfigParser()
try:
    config.read('config.ini', encoding='utf-8')
    if not config.sections():
        raise FileNotFoundError("config.ini not found or is empty.")
except (configparser.Error, FileNotFoundError, UnicodeDecodeError) as e:
    logging.error(f"CRITICAL: An unexpected error occurred while reading config.ini: {e}")
    sys.exit(1)

# --- API Models ---

class Device(BaseModel):
    id: str
    name: str
    ipAddress: str
    type: str

class NewBlockPayload(BaseModel):
    operator: str
    config: str
    diff: str
    changeType: str
    summary: str
    analysis: str
    security_risks: str
    
class ConfigPayload(BaseModel):
    config: str

class SessionPayload(BaseModel):
    username: str
    sessionId: str

# --- FastAPI App Initialization ---

app = FastAPI(
    title="ChainTrace Local Agent",
    description="Acts as a bridge between the ChainTrace UI and real network devices, and serves as the central data store for LAN collaboration.",
    version="3.5.0",
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Helper Functions ---

def get_device_info(device_id: str):
    device_id_upper = device_id.upper()
    if not config.has_option('device_map', device_id_upper):
        return None
    try:
        host, device_type = config.get('device_map', device_id_upper).split(',')
        return {
            'host': host.strip(), 'device_type': device_type.strip(),
            'username': config.get('credentials', 'username'),
            'password': config.get('credentials', 'password'),
            'secret': config.get('credentials', 'secret', fallback=None),
            'timeout': 15,
        }
    except (configparser.NoSectionError, configparser.NoOptionError) as e:
        logging.error(f"Configuration error for device '{device_id}': {e}")
        return None

def is_simulation_mode():
    try:
        return config.get('credentials', 'username').upper() == 'SIM_USER'
    except (configparser.NoSectionError, configparser.NoOptionError):
        return False

# --- API Endpoints ---

@app.get("/api/data")
def get_all_data():
    logging.info("Request received for GET /api/data")
    with data_lock:
        return _load_data_nolock()

@app.post("/api/reset", status_code=204)
def reset_data():
    logging.warning("Request received to RESET all data.")
    with data_lock:
        _save_data_nolock(INITIAL_DATA)
    return {}

@app.post("/api/devices", status_code=201)
def add_device(device: Device):
    logging.info(f"Request received to ADD device: {device.id}")
    with data_lock:
        data = _load_data_nolock()
        
        if any(d['id'] == device.id for d in data['devices']):
            raise HTTPException(status_code=409, detail=f"Device with ID '{device.id}' already exists.")
        
        data['devices'].append(device.dict())
        
        genesis_block_data = {
            "deviceId": device.id, "version": 1, "operator": "system_init",
            "config": f"hostname {device.name}\n!\n! Initial configuration created by ChainTrace.",
            "diff": f"+ hostname {device.name}\n+ !\n+ ! Initial configuration created by ChainTrace.",
            "changeType": "initial", "summary": "设备已创建。",
            "analysis": "这是新设备的第一个配置区块，用于建立基线。",
            "security_risks": "无。这是一个标准的初始设置。",
        }
        timestamp = datetime.datetime.utcnow().isoformat() + "Z"
        hash_hex = _calculate_block_hash(genesis_block_data, 0, timestamp, "0")
        
        genesis_block = {
            "index": 0, "timestamp": timestamp, "data": genesis_block_data,
            "prev_hash": "0", "hash": hash_hex
        }
        data['blockchains'][device.id] = [genesis_block]
        
        _save_data_nolock(data)
    return device

@app.delete("/api/devices/{device_id}", status_code=204)
def delete_device(device_id: str):
    logging.info(f"Request received to DELETE device: {device_id}")
    with data_lock:
        data = _load_data_nolock()
        
        initial_device_count = len(data['devices'])
        data['devices'] = [d for d in data['devices'] if d['id'] != device_id]
        
        if len(data['devices']) == initial_device_count:
            raise HTTPException(status_code=404, detail=f"Device with ID '{device_id}' not found.")
            
        if device_id in data['blockchains']:
            del data['blockchains'][device_id]
        
        _save_data_nolock(data)
    return {}

@app.post("/api/blockchains/{device_id}", status_code=201)
def add_block(device_id: str, payload: NewBlockPayload):
    logging.info(f"Request received to ADD block to device: {device_id}")
    new_block_to_return = None
    with data_lock:
        data = _load_data_nolock()
        
        if device_id not in data['blockchains'] or not data['blockchains'][device_id]:
            raise HTTPException(status_code=404, detail=f"Blockchain for device ID '{device_id}' not found or is empty.")
        
        chain = data['blockchains'][device_id]
        last_block = chain[-1]
        
        new_index = last_block['index'] + 1
        new_version = last_block['data']['version'] + 1
        prev_hash = last_block['hash']
        timestamp = datetime.datetime.utcnow().isoformat() + "Z"
        
        new_block_data = {"deviceId": device_id, "version": new_version, **payload.model_dump()}
        new_hash = _calculate_block_hash(new_block_data, new_index, timestamp, prev_hash)
        
        new_block = {
            "index": new_index, "timestamp": timestamp, "data": new_block_data,
            "prev_hash": prev_hash, "hash": new_hash
        }
        
        chain.append(new_block)
        _save_data_nolock(data)
        new_block_to_return = new_block

    return new_block_to_return

@app.get("/api/health")
def health_check():
    return {
        "status": "ok", "message": "ChainTrace Agent is running.",
        "mode": "simulation" if is_simulation_mode() else "live"
    }

@app.get("/api/device/{device_id}/config")
def get_config(device_id: str):
    logging.info(f"Received GET config for device: {device_id}")
    if is_simulation_mode():
        mock_config = f"hostname {device_id}\n!\n! End of simulated config"
        return {"config": mock_config}

    device_info = get_device_info(device_id)
    if not device_info:
        raise HTTPException(status_code=404, detail=f"Device ID '{device_id}' not found in configuration.")

    try:
        with ConnectHandler(**device_info) as net_connect:
            net_connect.enable()
            output = net_connect.send_command('show running-config', expect_string=r'#')
        return {"config": output}
    except Exception as e:
        logging.error(f"Error connecting to {device_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to connect to device: {e}")

@app.post("/api/device/{device_id}/config")
def set_config(device_id: str, payload: ConfigPayload):
    logging.info(f"Received POST config for device: {device_id}")
    if is_simulation_mode():
        return {"status": "success", "message": "Configuration push simulated."}

    device_info = get_device_info(device_id)
    if not device_info:
        raise HTTPException(status_code=404, detail=f"Device ID '{device_id}' not found in configuration.")
    
    config_commands = payload.config.splitlines()
    if not config_commands:
        raise HTTPException(status_code=400, detail="Configuration payload empty.")

    try:
        with ConnectHandler(**device_info) as net_connect:
            net_connect.enable()
            output = net_connect.send_config_set(config_commands)
        return {"status": "success", "output": output}
    except Exception as e:
        logging.error(f"Error pushing config to {device_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to push config: {e}")

@app.get("/api/sessions/{device_id}")
def get_device_sessions(device_id: str):
    with sessions_lock:
        return ACTIVE_SESSIONS.get(device_id, [])

@app.post("/api/sessions/{device_id}", status_code=204)
def join_device_session(device_id: str, payload: SessionPayload):
    with sessions_lock:
        current_sessions = ACTIVE_SESSIONS.get(device_id, [])
        # Robust "upsert" logic:
        # Remove any existing session with the same session ID to handle refreshes.
        updated_sessions = [s for s in current_sessions if s['sessionId'] != payload.sessionId]
        # Add the new/updated session.
        updated_sessions.append(payload.model_dump())
        ACTIVE_SESSIONS[device_id] = updated_sessions
    
    user_list = [f"{s['username']}({s['sessionId'][-4:]})" for s in ACTIVE_SESSIONS.get(device_id, [])]
    logging.info(f"User '{payload.username}' joined session for '{device_id}'. Current viewers: {user_list}")
    return {}

@app.delete("/api/sessions/{device_id}/{session_id}", status_code=204)
def leave_device_session_endpoint(device_id: str, session_id: str):
    with sessions_lock:
        if device_id in ACTIVE_SESSIONS:
            # Create the new list without the leaving session
            current_sessions = ACTIVE_SESSIONS[device_id]
            updated_sessions = [s for s in current_sessions if s['sessionId'] != session_id]

            # Only log and modify if a session was actually removed
            if len(updated_sessions) < len(current_sessions):
                logging.info(f"Session {session_id} left '{device_id}'.")
                
                # If the list is now empty, remove the key entirely. Otherwise, update it.
                if not updated_sessions:
                    del ACTIVE_SESSIONS[device_id]
                    logging.info(f"All sessions for device '{device_id}' closed. Removing key.")
                else:
                    ACTIVE_SESSIONS[device_id] = updated_sessions
    return {}

if __name__ == "__main__":
    import uvicorn
    with data_lock:
        _load_data_nolock() # Initialize data file on startup
    try:
        host = config.get('server', 'host', fallback='127.0.0.1')
        port = config.getint('server', 'port', fallback=8000)
        logging.info(f"Starting ChainTrace Agent server at http://{host}:{port}")
        uvicorn.run(app, host=host, port=port)
    except (configparser.NoSectionError, configparser.NoOptionError) as e:
        logging.error(f"Could not read server config, using defaults. Error: {e}")
        uvicorn.run(app, host="127.0.0.1", port=8000)